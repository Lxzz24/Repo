# **数组**

# 3.1 数组的概述
1. **数组(Array)**，是多个相同类型数据按一定顺序排列的集合，并使用一个名字命名，并通过编号的方式对这些数据进行统一管理。
1. 数组相关的概念

> 数组名
> 元素
> 角标、下标、索引
> 数组的长度：元素的个数

3. **数组的特点：**
   1. 数组是有序排列的。
   1. 数组属于引用数据类型的变量。数组的元素既可以是基本数据类型，也可以是引用数据类型。
   1. 创建数组对象会在内存中开辟一整块连续的空间（不连续的-->链表）。
   1. 数组的长度一旦确定，就不能修改。
4. **数组的分类**

①按照维数：一维数组、二维数组...
②按照数组元素的类型：基本数据类型元素的数组，引用数据类型元素的数组。

![image.png](https://cdn.jsdelivr.net/gh/Lxzz24/images/SE0301.png)


## ex： 数据结构

1. 数据与数据之间的逻辑关系：集合、一对一、一对多、多对多
1. 数据的存储结构：
   1. 线性表（一对一）：顺序表（比如：数组）、链表、栈（一个口，先进后出）、队列（一个入口，一个出口，先进先出）
   1. 树形结构（一对多）：二叉树
   1. 图形结构（多对多）

## ex： 算法（基础）
排序算法：
搜索算法：



# 3.2 一维数组的使用***
## ① 一维数组的声明和初始化
`int num;`//声明
`num = 10;`//初始化
`int id = 1001;`//声明+初始化
**Ⅰ 静态初始化:数组的初始化和数组元素的赋值操作同时进行**
`int[] ids = new int[]{1001,1002,1003,1004};`​
**Ⅱ 动态初始化:数组的初始化和数组元素的赋值操作分开进行**
`String[] names = new String[5];`
> 错误的方式：
> //`int[] arr1 = new int[];`
> //`int[5] arr2 = new int[5];`
> //`int[] arr3 = new int[3]{1,2,3};`

## ② 如何调用数组的指定位置的元素
> 通过角标的方式。//数组的角标（或索引）从0开始，到数组的长度-1结束。

`names[3] = "吴签";`
## ③ 如何获取数组的长度
`System.out.println(names.length);`
> 数组一旦初始化，其长度就是确定的。
> arr.length数组长度一旦确定，就不可修改。

## ④ 如何遍历数组
```java
for(int i = 0;i < names.length;i++){
	System.out.println(names[i]);
}
```
## ⑤ 数组元素的默认初始化值
> 数组元素是整型：0
> 数组元素是浮点型：0.0
> 数组元素是char型：0或'\u0000'，而非'0'
> 数组元素是boolean型：false
> 数组元素是引用数据型：null
## *⑥ 数组的内存解析
![image.png](https://cdn.jsdelivr.net/gh/Lxzz24/images/SE0302.png)

# 3.3 多维数组的使用*
## 对于二维数组的理解
> 数组属于引用数据类型
> 数组的元素也可以是引用数据类型
> **一个一维数组A的元素如果还是一个一维数组类型，则此数组A称为"二维数组"**

> 我们可以看成是一维数组array1又作为另一个一维数组array2的元素而存在。
> 从数组底层的运行机制来看，其实没有多维数组。

## 二维数组的使用
### ① 二维数组的声明和初始化
```java
//静态初始化
		int[][] arr1 = new int[][]{{1,2,3},{4,5},{6,7,8}};
//动态初始化1
		String[][] arr2 = new String[3][2];//三行二列
//动态初始化2
		String[][] arr3 = new String[3][];
```
> 错误的方式：
> //`String[][] arr4 = new String[][4];`
> 	//`String[4][3] arr5 = new String[][];`
> 	//`int[][] arr6 = new int[4][3]{{1,2,3},{4,5},{6,7,8}};`

### ② 如何调用数组的指定位置的元素
`System.out.println(arr1[0][1]);`//2
//`System.out.println(arr3[0]);`//null


### ③ 如何获取数组的长度
//`int arr4[][] = new int[][]{{1,2,3},{4,5},{6,7,8}};`
`System.out.println(arr4.length);`//3
`System.out.println(arr4[0].length);`//3
`System.out.println(arr4[1].length);`//2

### ④ 如何遍历数组
```java
for(int i = 0;i < arr4.length;i++){
	for(int j = 0;j < arr4[i].length;j++){
		System.out.print(arr4[i][j] + " ");
	}
	System.out.println();
}		
```

### ⑤ 数组元素的默认初始化值
> 规定：二维数组分为外层数组的元素，内层数组的元素
> 		`int[][] arr = new int[4][3];`
> 		外层元素：`arr[0],arr[1]...`
> 		内层元素：`arr[0][0],arr[0][1]...`

> **针对初始化方式一：**比如，`int[][] arr = new int[4][3];`
> 外层元素的初始化值为：地址值
> 内层元素的初始化值为：与一维数组初始化情况相同

```java
int[][] arr = new int[4][3];
System.out.println(arr[0]);//[I@15db9742(地址值)
//[：一维数组，I：int型，@15db9742：具体地址（十六进制）
System.out.println(arr[0][0]);//0
System.out.println(arr);//[[I@6d06d69c
```
> **针对初始化方式二：**比如，`int[][] arr = new int[4][];`
> 外层元素的初始化值为：null
> 内层元素的初始化值为：不能调用，否则报错：NullPointerException

```java
double[][] arr3 = new double[4][];
System.out.println(arr3[1]);//null
System.out.println(arr3[1][0]);//NullPointerException
```
### ⑥ 二维数组的内存解析

![image.png](https://cdn.jsdelivr.net/gh/Lxzz24/images/SE0303.png)

# 3.4 数组中涉及的常见算法
## ① 数组元素的赋值(杨辉三角、回形数等)
#### 杨辉三角

![image.png](https://cdn.jsdelivr.net/gh/Lxzz24/images/SE0304.png)

1. 声明并初始化二维数组

`int[][] yanghui = new int[10][];`

2. 给数组的元素赋值
```java
for(int i = 0;i < yanghui.length;i++){
	yanghui[i] = new int[i+1];
    for(int j = 0;j < yanghui[i].length;j++){
		if(j == 0 || j == i){
            //2.1 给首末元素赋值
			yanghui[i][j] = 1;
		}else if(i >= 2 && j >= 1){
            //2.2 给每行的非首末元素赋值
			yanghui[i][j] = yanghui[i-1][j-1] + yanghui[i-1][j];
		}
	}
}
```

3. 遍历二维数组
```java
for(int i = 0;i < yanghui.length;i++){
    for(int j = 0;j < yanghui[i].length;j++){
		System.out.print(yanghui[i][j] + "\t");
	}
	System.out.println();
}
```
ex：（1+1）i 展开式的每一项 --> 杨辉三角每行的元素
如：`yanghui[2] = (1 + 1)2 = 1 + 2 + 1`
`(a + b)2 = a2 + 2ab + b2;`
#### 回形数
[见章节练习题-编程题-3](https://www.yuque.com/u2324231/klk8hf/kgab1v#zSjI4)
## ② 求数值型数组中元素的最大值、最小值、平均数、总和等
> 数组：10~99的随机数

```java
int[] arr = new int[10];
for (int i = 0; i < arr.length; i++) {
	arr[i] = (int) (Math.random() * 90 + 10);
}
```
### 求数组元素的最大值
```java
int maxValue = arr[0];
for (int i = 1; i < arr.length; i++) {
	if (maxValue < arr[i]) {
		maxValue = arr[i];
	}
}
```
### 求数组元素的最小值
```java
int minValue = arr[0];
for (int i = 1; i < arr.length; i++) {
	if (minValue > arr[i]) {
		minValue = arr[i];
	}
}
```
### 求数组元素的总和
```java
int sum = 0;
for (int i = 0; i < arr.length; i++) {
	sum += arr[i];
}
```
### 求数组元素的平均值
`double avgValue = sum / arr.length;`

## ③ 数组的复制、反转、查找(线性查找、二分法查找)
> 数组：

`String[] arr = new String[]{"JJ","DD","MM","BB","GG","AA"};`

### 数组的复制(区别于数组变量的赋值：arr1 = arr)
```java
String[] arr1 = new String[arr.length];
for(int i = 0;i < arr.length;i++){
	arr1[i] = arr[i];
	System.out.print(arr1[i] + "\t");
}
```
### 数组的反转
```java
String temp;
//方法一：
for(int i = 0;i < arr.length/2;i++){
	temp = arr[i];
	arr[i] = arr[arr.length - i - 1];
	arr[arr.length - i - 1] = temp;
}
//方法二：
for(int i = 0,j = arr.length - 1;i < j;i++,j--){
	temp = arr[i];
	arr[i] = arr[j];
	arr[j] = temp;
}
```
### 数组的查找
#### 线性查找
```java
String dest = "BB";
boolean isFlag = true;
for(int i = 0;i < arr.length;i++){
	if(dest.equals(arr[i])){
		System.out.println("找到了指定的元素，位置为：" + i);
		isFlag = false;
		break;
	}
}
if(isFlag){
	System.out.println("没有找到指定元素");
}
```
#### 二分法查找
> //前提：所要查找的数组必须有序
> `int[] arr2 = new int[]{-98,-34,2,34,54,66,79,105,210,333};`

```java
int dest1 = -34;
int head = 0;//初始的首索引
int end = arr2.length - 1;//初始的末索引
isFlag = true;
while(head <= end){
	int middle = (head + end)/2;
	if(dest1 == arr2[middle]){
		System.out.println("找到了指定的元素，位置为：" + middle);
		isFlag = false;
		break;
	}else if(arr2[middle] > dest1){
		end = middle - 1;
	}else{
		head = middle + 1;
	}
}
if(isFlag){
	System.out.println("没有找到指定元素");
}		
```
## ④ 数组元素的排序算法
> **排序：**假设含有n个记录的序列为{R1，R2，...,Rn},其相应的关键字序列为{K1，K2，...,Kn}。将这些记录重新排序为{Ri1,Ri2,...,Rin},使得相应的关键字值满足条Ki1<=Ki2<=...<=Kin,这样的一种操作称为排序。
> - 通常来说，排序的目的是快速查找。

### 衡量排序算法的优劣：
> 1. **时间复杂度**：分析关键字的比较次数和记录的移动次数
> 1. **空间复杂度**：分析排序算法中需要多少辅助内存
> 1. **稳定性**：若两个记录A和B的关键字值相等，但排序后A、B的先后次序保
> 
持不变，则称这种排序算法是稳定的。

### 排序算法分类：
> **​内部排序**和**外部排序**。 
> - 内部排序：整个排序过程不需要借助于外部存储器（如磁盘等），所有排序操作都在内存中完成。
> - 外部排序：参与排序的数据非常多，数据量非常大，计算机无法把整个排序过程放在内存中完成，必须借助于外部存储器（如磁盘）。外部排序最常见的是多路归并排序。可以认为外部排序是由多次内部排序组成。

### 十大内部排序算法
> - **选择排序**
>    - **直接选择排序、堆排序**
> - **交换排序**
>    - **冒泡排序、快速排序**
> - **插入排序**
>    - **直接插入排序、折半插入排序、Shell排序**
> - **归并排序**
> - **桶式排序**
> - **基数排序**

> **算法的5大特征**

| **输入(Input)** | 有0个或多个输入数据，这些输入必须有清楚的描述和定义 |
| --- | --- |
| **输出(Output) ** | 至少有1个或多个输出结果，不可以没有输出结果 |
| **有穷性**
**(有限性，Finiteness)** | 算法在有限的步骤之后会自动结束而不会无限循环，并且每一个步骤可以在可接受的时间内完成 |
| **确定性**
**(明确性，Definiteness) ** | 算法中的每一步都有确定的含义，不会出现二义性 |
| **可行性**
**(有效性，Effectiveness)** | 算法的每一步都是清楚且可行的，能让用户用纸笔计算而求出答案 |

### 冒泡排序
冒泡排序的原理非常简单，它重复地走访过要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来。
#### 基本思想：

1. 比较相邻的元素。如果第一个比第二个大（升序），就交换他们两个。
1. 对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。
1. 针对所有的元素重复以上的步骤，除了最后一个。
1. 持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较为止。
#### 具体过程：
若序列中有 n 个元素，通常进行 n - 1 趟。第 1 趟，针对第R[1] 至R[n]个元素进行。第 2 趟，针对第 R[1] 至 R[n－1] 个元素进行。…… 第 n-1 趟，针对第 R[1] 至 R[2] 个元素进行。
**每一趟进行的过程**：从第一个元素开始，比较两个相邻的元素。若相邻的元素的相对位置不正确,则进行交换；否则继续比较下面两个相邻的元素。
**结束条件**：在任何一趟进行过程中，未出现交换。
```java
for(int i = 0;i < arr.length -1;i++){
	for(int j = 0;j < arr.length - 1 - i;j++){
		if(arr[j] > arr[j + 1]){
			int temp = arr[j];
			arr[j] = arr[j + 1];
			arr[j + 1] = temp;
		}
	}
}
```
### 快速排序
快速排序通常明显比同为O(nlogn)的其他算法更快，因此常被采用，而且快排采用了分治法的思想，所以在很多笔试面试中能经常看到快排的影子。
#### 排序思想：

1. 从数列中挑出一个元素，称为"基准"（pivot）
1. 重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区结束之后，该基准就处于数列的中间位置。这个称为分区（partition）操作。
1. 递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序。
1. 递归的最底部情形，是数列的大小是零或一，也就是永远都已经被排序好了。虽然一直递归下去，但是这个算法总会结束，因为在每次的迭代（iteration）中，它至少会把一个元素摆到它最后的位置去。

![image.png](https://cdn.jsdelivr.net/gh/Lxzz24/images/SE0305.png)

### 各种内部排序方法性能比较

1. **从平均时间而言**：快速排序最佳。但在最坏情况下时间性能不如堆排序和归并排序。
2. **从算法简单性看**：由于直接选择排序、直接插入排序和冒泡排序的算法比较简单，将其认为是简单算法。对于Shell排序、堆排序、快速排序和归并排序算法，其算法比较复杂，认为是复杂排序。
3. **从稳定性看**：直接插入排序、冒泡排序和归并排序时稳定的；而直接选择排序、快速排序、 Shell排序和堆排序是不稳定排序
4. **从待排序的记录数n的大小看**，n较小时，宜采用简单排序；而n较大时宜采用改进排序



[详见3-数组-排序](https://www.yuque.com/u2324231/klk8hf/ae4179#hgRkq)
# 3.5 Arrays工具类的使用
① 定义在java.util包下。
② Arrays:提供了很多操作数组的方法。

| **boolean equals(int[] a,int[] b) ** | 判断两个数组是否相等。 |
| --- | --- |
| **String toString(int[] a)** | 输出数组信息。 |
| **void fill(int[] a,int val) ** | 将指定值填充到数组之中。  |
| **void sort(int[] a) ** | 对数组进行排序。 |
| **int binarySearch(int[] a,int key)** | 对排序后的数组进行二分法检索指定的值。 |

```java
//1.boolean equals(int[] a,int[] b) :判断两个数组是否相等。
int[] arr1 = new int[]{1,2,3,4};
int[] arr2 = new int[]{1,3,2,4};
boolean isEquals = Arrays.equals(arr1,arr2);
System.out.println(isEquals);

//2.String toString(int[] a) : 输出数组信息。
System.out.println(Arrays.toString(arr1));
		
//3.void fill(int[] a,int val) : 将指定值填充到数组之中。
Arrays.fill(arr1, 10);
System.out.println(Arrays.toString(arr1));
	
//4.void sort(int[] a) : 对数组进行排序。
Arrays.sort(arr2);
System.out.println(Arrays.toString(arr2));
		
//5.int binarySearch(int[] a,int key) : 对排序后的数组进行二分法检索指定的值。
int[] arr3 = new int[]{-98,-34,2,34,54,66,79,105,210,333};
int index = Arrays.binarySearch(arr3, 211);
if(index >= 0){
	System.out.println(index);
}else{
	System.out.println("未找到");
}		
```
# 3.6 数组使用中的常见异常
## 1.数组角标越界的异常：ArrayIndexOutOfBoundsException
```java
		int[] arr = new int[]{1,2,3,4,5};
		
//		for(int i = 0;i <= arr.length;i++){
//			System.out.println(arr[i]);
//		}
//		System.out.println(arr[-2]);
```
## 2.空指针异常：NullPointerException
```java
		//情况一：
//		int[] arr1 = new int[]{1,2,3};
//		arr1 = null;
//		System.out.println(arr1[0]);
		
		//情况二：
//		int[][] arr2 = new int[4][];
//		System.out.println(arr2[0]);
//		System.out.println(arr2[0][0]);
		
		//情况三：
		String[] arr3 = new String[]{"AA","BB","CC"};
		arr3[0] = null;
		System.out.println(arr3[0].toString());
```
