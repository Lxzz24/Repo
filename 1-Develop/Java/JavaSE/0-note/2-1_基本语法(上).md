#

# **2.1 关键字和保留字**

## 关键字（keyword）
- 定义：
  - 被 Java 语言赋予了特殊含义，用做专门用途的字符串
- 特点：
  - 关键字中所有字母都为小写
- [官方地址](https://docs.oracle.com/javase/tutorial/java/nutsandbolts/_keywords.html)

![image.png](https://cdn.jsdelivr.net/gh/Lxzz24/Repo/images/SE0211.png)

![image.png](https://cdn.jsdelivr.net/gh/Lxzz24/Repo/images/SE0212.png)

## 保留字（reserved word）

> [!ATTENTION]
> 现有版本尚未使用，但以后版本可能作为关键字。自己命名标识符时要避免。  
> goto、const

# **2.2 标识符**（Identifier）

Java 对各种变量、方法和类等要素命名时使用的字符序列

> 凡是自己可以起名字的地方都叫标识符

## Ⅰ 标识符的命名规则： 

> [!WARNING]
> 如果不遵守如下规则，编译不通过！**需要严格遵守！**
> 1. 由26个英文字母大小写，0-9 ，_ 或 $ 组成
> 2. 数字不可以开头
> 3. 不可以使用关键字和保留字，但能包含关键字和保留字
> 4. Java 中严格区分大小写，长度无限制
> 5. 标识符不能包含空格

## Ⅱ Java中的名称命名规范： 

> [!TIP]
> 如果不遵守如下规则，编译可以通过！**建议遵守！**
> - **包名**：多单词组成时所有字母都小写：xxxyyyzzz
> - **类名、接口名**：多单词组成时，所有单词的首字母大写：XxxYyyZzz 
> - **变量名、方法名**：多单词组成时，第一个单词首字母小写，第二个单词开始每个单词首字母大写：xxxYyyZzz 
> - **常量名**：所有字母都大写。多单词时每个单词用下划线连接：XXX_YYY_ZZZ	

> [!ATTENTION]
> 1. 在起名字时，为了提高阅读性，要尽量有意义，“见名知意”。
> 2. java 采用 unicode 字符集，因此标识符也可以使用汉字声明，但是不建议使用。 


# **2.3 变量**

## 概念：	
- **内存中的一个存储区域**
- 该区域的数据可以在同一类型范围内不断变化
- 变量是程序中最基本的存储单元
- 包含变量类型、变量名和存储的值

## 作用：
- **用于在内存中保存数据**
- 使用变量名来访问这块区域的数据
- 变量的作用域：定义所在的一对`{}`内

## 变量的使用

Java定义变量的格式：
- `数据类型 变量名 = 变量值；`
- 或 `数据类型 变量名；`
- `变量名 = 变量值;`  

> [!ATTENTION]
> ① 变量必须先声明，后使用。  
> ② 变量都定义在其作用域内。在作用域内，它是有用的。换句话说，出了作用域，就失效了。  
> ③ 同一个作用域内，不可以声明两个同名的变量。  

## 数据类型

### Ⅰ 按照数据类型来分

![image.png](https://cdn.jsdelivr.net/gh/Lxzz24/Repo/images/SE0213.png)

#### 整数类型

byte（1 字节 = 8 bit）\ short（2 字节）\ int（4 字节）\ long（8 字节）

1. byte 范围：-128 ~ 127
2. 声明 long 型变量，必须以 "l"/"L" 结尾
3. 通常定义整型变量时，使用 int 型

#### 浮点类型

float（4 字节） \ double（8 字节）

1. 浮点型，表示带小数点的数值
2. float 表示数值的范围比 long 还大
3. 定义 float 类型变量时，变量要以 "f"/"F" 结尾
4. 通常，定义浮点型变量时，使用 double 型

#### 字符类型

char（1 字符 = 2 字节）

1. 定义 char 型变量，通常使用一对  `''` ,内部只能写一个字符
2. 表示方式：
   1. 声明一个字符
   2. 转义字符 
   3. 直接使用 Unicode 值表示字符型常量
   - ASCII 码
     - 8 个二进制位，共规定了 128 个字符的编码
   - Unicode 编码
   - UTF-8


> [!TIP]
> - \n 换行符
> - \t 制表符
> - \b 退格符
> - \r 回车符
> - \" 双引号
> - \' 单引号
> - \\反斜线


> [!ATTENTION]
> 命令行是以 GBK 编码运行的，无法识别 UTF-8 的字符（EditPlus 中 ANSI 就等同于 GBK 编码）


#### 布尔类型

boolean
	
1. 只能取两个值之一：true 、false
2. 常常在条件判断、循环结构中使用

### Ⅱ 按变量在类中声明的位置

> 在方法体外，类体内声明的变量称为**成员变量**。
> 在方法体内部声明的变量称为**局部变量**。

![image.png](https://cdn.jsdelivr.net/gh/Lxzz24/Repo/images/SE0214.png)

## 基本数据类型之间的运算规则

> [!ATTENTION]
> 前提：这里讨论的只是 7 种基本数据类型变量间的运算。不包括 boolean 类型。

### 1.自动类型提升：
结论：当容量小的数据类型的变量与容量大的数据类型的变量做运算时，结果自动提升为容量大的数据类型。

$$byte、char、short → int → long → float → double → String$$

特别的：当byte、char、short三种类型的变量做运算时，结果为int型

### 2.强制类型转换：

> 自动类型提升运算的逆运算

1. 需要使用强转符：（）
2. 注意点：强制类型转换，可能导致精度损失。
	- 说明：此时的容量大小指的是，表示数的范围的大和小。
	- 比如：float 的容量要大于 long 的容量。

> [!TIP]
> 编码情况：
> - 整型常量，默认类型为 int 型；
> - 浮点型常量，默认类型为 double 型。

> [!NOTE]
> String类型变量的使用
> 1. String属于引用数据类型，翻译为：字符串
> 2. 声明String类型变量时，使用一对""
> 3. String可以和8种基本数据类型变量做运算，且运算只能是连接运算。
> 4. 运算的结果仍是String类型
​

#### 练习 1

```java
String str1 = 4; 																	//判断对错：×
String str2 = 3.5f + ""”; 															//判断str2对错：√
System.out.println(str2); 															//输出：”3.5” 
System.out.println(3+4+""Hello!”); 													//输出：7Hello! 
System.out.println(""Hello!”+3+4); 													//输出：Hello!34 
System.out.println(‘a’+1+""Hello!”); 												//输出：98Hello! 
System.out.println(""Hello”+‘a’+1); 												//输出：Helloa1
```

#### 练习 2	判断是否能通过编译

```java
//1
short s = 5; 
s = s-2;																			//判断：×
//2
byte b = 3; 
b = b + 4;																			//判断：×
//3
b = (byte)(b+4);																	//判断：√ 
//4	
char c = ‘a’; 
int i = 5; 
float d = .314F; 
double result = c+i+d;																//判断：√ 
//5	
byte b = 5; 
short s = 3; 
short t = s + b;																	//判断：×

```
## 进制：

所有数字在计算机底层都以二进制形式存在。

| 十 | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 | 11 | 12 | 13 | 14 | 15 | 16 | 17 |
| --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- |
| 十六 | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | A | B | C | D | E | F | 10 | 11 |
| 八 | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 10 | 11 | 12 | 13 | 14 | 15 | 16 | 17 | 20 | 21 |
| 二 | 0 | 01 | 10 | 11 | 100 | 101 | 110 | 111 | 1000 | 1001 | 1010 | 1011 | 1100 | 1101 | 1110 | 1111 | 10000 | 10001 |

### 对于整数，有四种表示方式： 

- 二进制(binary)：0,1 ，满 2 进 1.以 0b 或 0B 开头。 
- 十进制(decimal)：0-9 ，满 10 进 1。 
- 八进制(octal)：0-7 ，满 8 进 1. 以数字 0 开头表示。 
- 十六进制(hex)：0-9 及 A-F，满 16 进 1. 以 0x 或 0X 开头表示。
  - 此处的A-F不区分大小写。如：0x21AF + 1 = 0X21B0

> - 原码：直接将一个数值换成二进制数。最高位是符号位;  
> - 负数的反码：是对原码按位取反，只是最高位（符号位）确定为 1;  
> - 负数的补码：其反码加 1。  


!> **计算机底层都以补码的方式来存储数据！**

- +127：
  - 0111 1111
- -127：
  - 1111 1111 原码
  - 1000 0000 反码
  - 1000 0001 补码
- -128：
  - 1000 0000 补码

$$(-1) + (-127) = [1000 0001]原 + [1111 1111]原 = [1111 1111]补 + [1000 0001]补 = [1000 0000]补$$

> [!ATTENTION]
> -1-127 的结果应该是 -128, 在用补码运算的结果中, [1000 0000]补 就是 -128.
> 但是注意因为实际上是使用以前的 -0 的补码来表示 -128，所以 -128 并没有原码和反码表示，
> (对 -128 的补码表示 **[1000 0000]补** 算出来的原码是 **[0000 0000]原**，这是不正确的)，
> 使用补码，不仅仅修复了 0 的符号以及存在两个编码的问题，而且还能够多表示一个最低数。
> 这就是为什么 8 位二进制，使用原码或反码表示的范围为 [-127, +127]，
> 而使用补码表示的范围为 [-128, 127]。


### 进制间的转换

- 十进制 → 二进制 ：
  - **除二取余的逆**
- 二进制 → 八进制 ：
  - **每 3 个一位**
- 二进制 → 十六进制	：
  - **每 4 个一位**
 
> [!TIP]
> 开发过程中： 	
> - toBinaryString(int i);
> - toOctalString(int i);					
> - toHexString(int i);

# **2.4 运算符**

## Ⅰ 算术运算符 

`+`(正)、 `-`(负)、 `+`、 `-`、 `*`、 `/`

- `%` : 取余（模）运算
  - 结果的符号与被模数的符号相同
  - 开发中，经常使用 % 来判断能否被除尽的情况

- `(前)++` : 先自增 1，后再运算
- `(后)++` : 先运算，后自增 1 

> [!ATTENTION]
> 注意点：自增 1 不会改变本身变量的数据类型

```java
//问题:
byte bb1 = 127;
bb1++;
System.out.println("bb1 = " + bb1); //-128,溢出
```

- `(前)--` 先自减 1，后再运算
- `(后)--` 先运算，后自减 1


## Ⅱ 赋值运算符

`=`  

扩展赋值运算符：`+=`，`-=`，`*=`，`/=`，`%=`

## Ⅲ 比较运算符（关系运算符）

| 运算符 | 运算 | 范例 | 结果 |
| :--: | :--: | :--: | :--: |
| `==` | 相等于 | 4 == 3 | false |
| `!=` | 不等于 | 4 != 3 | true |
| `<` | 小于 | 4 < 3 | false |
| `>` | 大于 | 4 > 3 | true |
| `<=` | 小于等于 | 4 <= 3 | false |
| `>=` | 大于等于 | 4 >= 3 | true |
| `instanceof` | 检查是否是类的对象 | "Hello" instanceof String | true |

> [!TIP]
> 1. 比较运算符的结果是 boolean 类型
> 2. 区分 `==` 和 `=`

## Ⅳ 逻辑运算符
`&`	逻辑与 		`|`	逻辑或 		`!`	逻辑非
`&&`	短路与 		`||`	短路或 		`^`	逻辑异或	

![image.png](https://cdn.jsdelivr.net/gh/Lxzz24/Repo/images/SE0215.png)

> [!NOTE]
> 区分：**&** 与 **&&**
> - 相同点1：& 与 && 的运算结果相同
> - 相同点2：当符号左边是 true 时，二者都会执行符号右边的运算
> - 不同点：当符号左边时 false 时，&继续执行符号右边的运算。&&不再执行符号右边的运算
> - 开发中，推荐使用 && 。

> [!NOTE]
> 区分：**|** 与 **||**	
> - 相同点1：| 与 || 的运算结果相同
> - 相同点2：当符号左边是false时，二者都会执行符号右边的运算
> - 不同点：当符号左边时true时，| 继续执行符号右边的运算。|| 不再执行符号右边的运算。
> - 开发中，推荐使用 || 。	

## Ⅴ 位运算符
| 运算符 | 运算 | 范例 | 细节 |
| :--: | :--: | :--: | --- |
| `<<` | 左移 | 3 << 2 = 12 --> 3 * 2 * 2 = 12 | 空位补0，被移除的高位丢弃，空缺位补0。 |
| `>>` | 右移 | 3 >> 1 = 1 --> 3 / 2 = 1 | 被移位的二进制最高位是0，右移后，空缺位补0；最高位是1，空缺位补1。 |
| `>>>` | 无符号右移 | 3 >>> 1 = 1 --> 3 / 2 = 1 | 被移位二进制最高位无论是0或是1，空缺位都用0补。 |
| `&` | 与运算 | 6 & 3 = 2 | 二进制位进行&运算，只有1&1时结果是1，否则是0； |
| `|` | 或运算 | 6 | 3 = 7 | 二进制位进行 | 运算，只有0 | 0时结果是0，否则是1； |
| `^` | 异或运算 | 6 ^ 3 = 5 | 相同二进制位进行^运算，结果是0： 1^1=0,0^0=0；不相同二进制位进行^运算结果是1： 1^0=1,0^1=1； |
| `~` | 取反运算 | ~6 = -7 | 正数取反，各二进制码按补码各位取反；负数取反，各二进制码按补码各位取反； |

> 结论：
> 1. 位运算符操作的都是整型的数据
> 2. `<<`：在一定范围内，每向左移一位，相当于 * 2
> 3. `>>`：在一定范围内，每向右移一位，相当于 / 2

$$m = k ^ n = (m ^ n) ^ n$$

## Ⅵ 三元运算符

## 结构： 

$$(条件表达式) ? 表达式 1 : 表达式 2$$

## 说明：

1. 条件表达式的结果为boolean类型
2. 根据条件表达式真或假，决定执行表达式1，还是表达式2.
	- 如果表达式为true，则执行表达式1；
	- 如果表达式为false，则执行表达式2；
3. 表达式1 和表达式2 要求是一致的。
4. 三元运算符可以嵌套使用

> [!NOTE]
> - 凡是可以使用三元运算符的地方，都可以改写为 if-else ：反之，不成立。
> - 如果程序既可以使用三元运算符，又可以使用 if-else 结构，那么优先选择三元运算符。
> - 简洁、执行效率高。


## Ⅶ 运算符的优先级

![image.png](https://cdn.jsdelivr.net/gh/Lxzz24/Repo/images/SE0216.png)
