# 
# 4.1 面向过程(POP)与面向对象(OOP)
- 二者都是一种思想，面向对象是相对于面向过程而言的。
   - **面向过程**，强调的是功能行为，以函数为最小单位，考虑怎么做。
   - **面向对象**，将功能封装进对象，强调具备了功能的对象，以类/对象为最小单位，考虑谁来做。
- 面向对象更加强调运用人类在日常的思维逻辑中采用的思想方法与原则，如抽象、分类、继承、聚合、多态等


> **面向对象的三大特征**
> - 封装 (Encapsulation)
> - 继承 (Inheritance)
> - 多态 (Polymorphism)

> **面向对象的思想概述**
> - 程序员从面向过程的执行者转化成了面向对象的指挥者
> - 面向对象分析方法分析问题的思路和步骤： 
>    - 根据问题需要，选择问题所针对的现实世界中的实体。 
>    - 从实体中寻找解决问题相关的属性和功能，这些属性和功能就形成了概念世界中的类。 
>    - 把抽象的实体用计算机语言进行描述，形成计算机世界中类的定义。即借助某种程序语言，把类构造成计算机能够识别和处理的数据结构。
>    - 将类实例化成计算机世界中的对象。对象是计算机世界中解决问题的最终工具。

# 4.2 Java基本元素：类和对象
## 类(Class)
是对一类事物的描述，是抽象的、概念上的定义
## 对象(Object)
是实际存在的该类事物的每个个体，因而也称为实例(instance)。 
## “万事万物皆对象”
> 可以理解为：类 = 抽象概念的人；对象 = 实实在在的某个人
> - 面向对象程序设计的重点是类的设计
> - 类的设计，其实就是类的成员的设计

## Java类及类的成员
常见的类的成员有：
> **属 性**：对应类中的成员变量
> **行 为**：对应类中的成员方法

`属性 = 成员变量 = Field = 域、字段`
`方法 = (成员)方法 = 函数 = Method`

![image.png](https://cdn.jsdelivr.net/gh/Lxzz24/IMG/repo/SE0401.png)

## 类的语法格式
`修饰符 class 类名 { `
`属性声明;`
`方法声明;`​
`}`
> 说明：
> 修饰符public：类可以被任意访问 
> 类的正文要用{ }括起来 

> 举例： 
> public class Person{ 
> private int age ; 
> //声明私有变量 age 
> public void showAge(int i) { //声明方法showAge( ) 
> age = i; 
> } 
> }

### 创建Java自定义类
> 步骤：
> 1. 定义类（考虑修饰符、类名）
> 2. 编写类的属性（考虑修饰符、属性类型、属性名、初始化值）
> 3. 编写类的方法（考虑修饰符、返回值类型、方法名、形参等）

# 4.3 对象的创建和使用
## 1. 创建类，设计类的成员
```java
class Person{
	//属性
	String name;
	int age;
	boolean isMale;
	
	//方法
	public void eat(){
		System.out.println("人可以吃饭");
	}
	public void sleep(){
		System.out.println("人可以睡觉");
	}
	public void talk(String language){
		System.out.println("人可以说话，使用的是：" + language);
	}
}
```
## 2. 创建类的对象 
```java
		Person p1 = new Person();
		//Scanner scan = new Scanner(System.in);
```
## 3. 通过“对象.属性”或“对象.方法”调用对象的结构
```java
//调用属性：“对象.属性”
		p1.name = "tom";
		p1.isMale = true;
		System.out.println(p1.name);
		
//调用方法：“对象.方法”
		p1.eat();
		p1.sleep();
		p1.talk("Chinese");
```
> 如果创建了一个类的多个对象，则每个对象都独立的拥有一套类的属性。（非static类）意味着，如果我们修改一个对象的属性a，则不影响另外一个对象属性a的值。

## 4. 内存解析

![image.png](https://cdn.jsdelivr.net/gh/Lxzz24/IMG/repo/SE0402.png)

![image.png](https://cdn.jsdelivr.net/gh/Lxzz24/IMG/repo/SE0403.png)

# 4.4 类的成员之一：属性
## 语法格式
`修饰符 数据类型 属性名 = 初始化值; `
## 属性（成员变量）	VS	局部变量
> **相同点：**
> 1. 定义变量的格式： `数据类型 变量名 = 变量值` 
> 1. 先声明，后使用
> 1. 变量都有其对应的作用域
> 
**不同点：**
> 1. 在类中声明的位置不同
> 
**属性**：直接定义在类的一对`{}`内。
> **局部变量**：声明在方法内、方法形参、代码块内、构造器形参、构造器内部的变量。
> 2. 关于权限修饰符的不同
> 
**属性**：可以在声明属性时，指明其权限，使用权限修饰符。
> 常用的权限修饰符，private、public、缺省、protected -->封装性
> 目前，大家声明属性时，都使用缺省就好。
> **局部变量**：不可以使用权限修饰符。
> 3. 默认初始化值的情况
> 
**属性**：类的属性，根据其类型，都有默认的初始化值。
>  	整型（byte、short、int、long），0
>  	浮点型（float、double）：0.0
>  	字符型（char）：0（或'\u0000'）
>  	布尔型（boolean）：false
>  	引用数据类型（类、数组、接口）：null
> **局部变量**：没有默认初始化值。
>  	意味着，我们在调用局部变量之前，一定要显式赋值。
>  	特别的，形参在调用时，我们赋值即可。
> 4. 在内存中加载的位置
> 
**属性**：加载到堆空间。（非static）
> **局部变量**：加载到栈空间。

# 4.5 类的成员之二：方法
## 方法：描述类应该具有的功能
> 比如： 
> Math类：	`sqrt()\random()\...`
> Scanner类：	`nextXxx();`
> Arrays类：	`sort()\binarySearch()\toString()\equals()\...`

## 语法格式
`权限修饰符 返回值类型 方法名(形参列表){`
`方法体`
//`return 返回值;`
`}`
> 举例：
> `public void eat(){}`
> `public void sleep(int hour){}`
> `public String getName(){}`
> `public String getNation(String nation){}`

## 说明
> 1. 关于权限修饰符，默认方法的权限修饰符先都使用public
> 
Java中规定的权限修饰符：private、public、缺省、protected --> 封装性再细说
> 2. 返回值类型： 有返回值 	 vs	无返回值
>    1. 如果方法有返回值，则必须再方法声明时，指定返回值的类型。同时，方法中，需要使用return关键字来返回指定类型的变量或者常量；如果方法没有返回值，则方法声明时，使用void来表示。通常，没有返回值的方法中，就不需要使用return。但是，如果使用的话，只能"return;"表示结束此方法的意思。
>    1. 我们定义方法该不该有返回值？
> 
① 题目要求	② 凭经验，具体问题具体分析
> 3. 方法名：属于标识符，遵循标识符的规则和规范：“见名知意”
> 3. 形参列表： 方法可以声明0个、1个、或多个形参。
>    1. 格式：数据类型1 形参1，数据类型2 形参2，...
>    1. 我们定义方法时，该不该定义形参？
> 
① 题目要求	② 凭经验，具体问题具体分析
> 5. 方法体：方法功能的体现。

## 方法的分类：
按照是否有形参及返回值

|  | 无返回值 | 有返回值 |
| --- | --- | --- |
| 无形参 | void 方法名（）{} | 返回值的类型 方法名（）{} |
| 有形参 | void 方法名（形参列表）{} | 返回值的类型 方法名（形参列表）{} |

## return关键字的使用：
1. 使用范围：使用在方法体中
2. 作用：
① 结束方法
② 针对于有返回值类型的方法，使用"return 数据"方法返回所要的数据。
3. 注意点：
return 关键字后面不可以声明执行语句。

## 方法的使用中，可以调用当前类的属性或方法
特殊的，方法A中又调用了方法A：递归方法（例如快速排序）。
方法中，不可以定义方法。

# *对象补充
## 一、理解“万事万物皆对象”

1. 在Java语言范畴中，我们都将功能、结构封装到类中，通过类的实例化，来调用具体的功能结构
	>Scanner,String等
	>文件：File
	>网络资源：URL
1. 涉及到Java语言与前端Html、后端的数据库交互时，前后端的结构在Java层面交互时，都体现为类、对象。

​

## 二、内存解析的说明

1. 引用类型的变量，只可能存储两类值：null 或 地址值（含变量的类型）



## 三、匿名对象的使用

1. 理解：我们创建的对象，没有显式的赋给一个变量名，即为匿名对象
```java
		//匿名对象
		new Phone().sendEmail();
		new Phone().playGame();
		
		new Phone().price = 1999;
		new Phone().showPrice();//0.0
```

2. 特征：匿名对象只能调用一次
2. 使用：如下
```java
public class InstanceTest {
	public static void main(String[] args) {
		PhoneMall mall = new PhoneMall();
		
        //匿名对象的使用
		mall.show(new Phone());
	}
}
class PhoneMall{
	public void show(Phone phone){
		phone.sendEmail();
		phone.playGame();
	}
}
class Phone{
	public void sendEmail(){
		System.out.println("发送邮件");
	}
	public void playGame(){
		System.out.println("玩游戏");
	}
}
```

# 4.6 再谈方法
## 方法的重载
定义
> 在同一个类中，允许存在一个以上的同名方法，只要它们的参数列表(参数个数或参数类型)不同即可。

> **“两同一不同”：**	
> 1. 同一个类、相同方法名
> 1. 参数列表不同：参数个数不同，参数类型不同

举例：
> `Arrays` 类中重载的 `sort()` / `binarySearch()`

```java
	//如下的4个方法就构成了重载
	public void getSum(int i, int j) {
		System.out.println("1");
	}

	public void getSum(double d1, double d2) {
		System.out.println("2");
	}

	public void getSum(String s,int i) {
		System.out.println("3");
	}
	public void getSum(int i,String s) {
		System.out.println("4");
	}
```
判断：
> 跟方法的权限修饰符、返回值类型、形参变量名、方法体都没有关系！

在通过对象调用方法时，**如何确定某一个指定的方法**
> 方法名 ---> 参数列表

面试题：方法的重载与重写的区别？
`throws` \ `throw`
`String` \ `StringBuffer` \ `StringBuilder`
`Collection` \ `Collections`
`final` \ `finally` \ `finalize`
...
抽象类、接口
`sleep()`  /  `wait()`

## 可变个数形参的方法
JDK 5.0新增内容
> 1. 可变个数形参的格式：数据类型 ... 变量名
> 1. 当调用可变个数形参的方法时，传入的参数个数可以是：0个，1个，2个...
> 1. 可变个数形参的方法与本类中方法名相同，形参不同的方法之间构成重载
> 1. 可变个数形参的方法与本类中方法名相同，形参类型也相同的数组之间，不构成重载
> 1. 可变个数形参在方法的形参中，必须声明在（形参列表的）末尾
> 1. 可变个数形参在方法的形参中，最多只能声明一个可变形参

```java
	public void show(int i){
		System.out.println("show(int i)");
	}
	public void show(String s){
		System.out.println("show(String s)");
	}
	public void show(String ... strs){
		System.out.println("show(String ... strs)");
		for(int i = 0;i < strs.length;i++){
			System.out.println(strs[i]);
		}
	}
	
	//不能与上一个方法同时存在
//	public void show(String[] str){
//		
//	}
```
## 方法参数的值传递机制

![image.png](https://cdn.jsdelivr.net/gh/Lxzz24/IMG/repo/SE0404.png)

![image.png](https://cdn.jsdelivr.net/gh/Lxzz24/IMG/repo/SE0405.png)

> 形参：方法定义时，声明的小括号内的参数

> 实参：方法调用时，实际传递给形参的数据

> **Java中参数传递机制：值传递**

如果参数是基本数据类型，此时实参赋给形参的是，实参真实存储的数据值。
如果参数是引用数据类型，此时实参赋给形参的是，实参存储数据的地址值。
> **关于变量的赋值**

如果变量是基本数据类型，此时赋值的是变量所保存的数据值。
如果变量是引用数据类型，此时赋值的是变量所保存的数据的地址值。
```java
public class ValueTransferTest {
	public static void main(String[] args) {
		
		String s1 = "hello";
		
		ValueTransferTest test = new ValueTransferTest();
		test.change(s1);
		
		System.out.println(s1);//hello
	}
	
	public void change(String s){
		s = "hi~~";
	}
}
```

![image.png](https://cdn.jsdelivr.net/gh/Lxzz24/IMG/repo/SE0406.png)

## 递归方法（了解）
> **一个方法体内调用它自身**

- 方法递归包含了一种隐式的循环，它会重复执行某段代码，但这种重复执行无须循环控制。
- 递归一定要向已知方向递归，否则这种递归就变成了无穷递归，类似于死循环。
```java
public class RecursionTest {
	
	public static void main(String[] args) {
		
		//例1. 计算1 ~ 100之间所有自然数的和
		//方式一：
		int sum = 0;
		for(int i = 0;i <= 100;i++){
			sum += i;
		}
		System.out.println(sum);
		
		//方式二：
		RecursionTest test = new RecursionTest();
		int sum1 = test.getSum(100);
		System.out.println(sum1);
		
	}
	
	//例1. 计算1 ~ n之间所有自然数的和
	public int getSum(int n){
		
		if(n == 1){
			return 1;
		}else{
			return n + getSum(n - 1);
		}
		
	}
	
	//例2. 计算1 ~ n之间所有自然数的乘积：阶乘n!
	public int getSum1(int n){
			
		if(n == 1){
			return 1;
		}else{
			return n * getSum1(n - 1);
		}
			
	}
		
	//例3. 7.2 f(0) = 1, f(1) = 4, f(n+2) = 2 * f(n+1) + f(n)
	public int getFx1(int n){
        if(n == 0){
            return 1;
        }else if(n == 1){
            return 4;
        }else{
//			return 2 * getFx1(n + 2) - getFx1(n + 1);
            return 2 * getFx1(n - 1) + getFx1(n - 2);
        }
    }
    
	//例4. 斐波那契数列(Fibonacci)
	public int getFibonacci(int n){
		if(n == 1 || n == 2){
			return 1;
		}else{
			return getFibonacci(n-1) + getFibonacci(n-2);
		}
	}
	//例5. 汉诺塔问题
		
	//例6. 快速排序
	
}
```
> **扩展：**

![image.png](https://cdn.jsdelivr.net/gh/Lxzz24/IMG/repo/SE0407.png)

![image.png](https://cdn.jsdelivr.net/gh/Lxzz24/IMG/repo/SE0408.png)

# 4.7 OOP特征一：封装与隐藏
`3W:  what?  why?  how?`
## 一、问题的引入：
 	当我们创建一个类的对象以后，我们可以通过"对象.属性"的方式，对对象的属性进行赋值，这里，赋值操作要受到属性的数据类型和存储范围的制约。除此之外，没有其他制约条件。
	但是，在实际问题中，我们往往需要给属性赋值，加入额外的限制条件。这个条件就不能在属性声明时体现，我们只能通过方法进行限制条件的添加。（比如，setLegs）同时，我们需要避免用户再使用"对象.属性"的方式对属性进行赋值，则需要将属性声明为私有的（private）。
	-->此时，针对于属性就体现了封装性。
​

## 二、封装性的体现：
① **我们将类的属性私有化 (private) ，同时，提供公共的 (public) 方法来获取 (getXxx) 和设置 (setXxx) 此属性的值。**
② 不对外暴露的私有的方法	
③ 单例模式（将构造器私有化）
④ 如果不希望类在包外被调用，可以将类设置为缺省的。
​

## 三、封装性的体现，需要权限修饰符来配合。
1. Java规定的4种权限（从小到大排列），**private**、**缺省**、**protected**、**public**
2. 4 种权限可以用来修饰类及类的内部结构：属性、方法、构造器、内部类
> 修饰类的话，只能使用：缺省、public

总结封装性：Java提供了4中权限修饰符来修饰类及类的内部结构，体现类及类的内部结构在被调用时的可见性的大小。
```java
	private int legs;//腿的个数
	
	//对属性的设置
	public void setLegs(int l){
		if(l >= 0 && l % 2 == 0){
			legs = l;
		}else{
			legs = 0;
//			抛出一个异常（暂时没有讲）
		}
	}
	
	//对属性的获取
	public int getLegs(){
		return legs;
	}
```

![image.png](https://cdn.jsdelivr.net/gh/Lxzz24/IMG/repo/SE0409.png)

## 为什么需要封装？封装的作用和含义？

- 我们程序设计追求“高内聚，低耦合”。
> 高内聚 ：类的内部数据操作细节自己完成，不允许外部干涉；
> 低耦合 ：仅对外暴露少量的方法用于使用；

- 隐藏对象内部的复杂性，只对外公开简单的接口。便于外界调用，从而提高系统的可扩展性、可维护性。通俗的说，把该隐藏的隐藏起来，该暴露的暴露出来。这就是封装性的设计思想。
- 
# 4.8 类的成员之三：构造器
construct：建设、建造。	
constructor：建设者。
## 一、构造器的作用：

1. 创建对象
1. 初始化对象的属性
## 二、使用说明：

1. 如果没有显式的定义类的构造器的话，则系统默认提供一个空参的构造器；
1. 定义构造器的格式：`权限修饰符  类名（形参列表）{}`
1. 一个类中定义的多个构造器，彼此构成重载；
1. 一旦我们显式的定义了类的构造器之后，系统就不再提供默认的空参构造器；
1. 一个类中，至少会有一个构造器。
## 三、总结：属性赋值的先后顺序
① 默认初始化值
② 显式初始化
③ 构造器中赋值
④ 通过"对象.方法"或"对象.属性"的方式，赋值
以上操作的先后顺序：① -> ② -> ③ -> ④

## 拓展：JavaBean
> 是一种Java语言写成的可重用组件。

所谓 `JavaBean` ，是指符合如下标准的Java类：

- 类是公共的
- 有一个无参的公共的构造器
- 有属性，且有对应的get、set方法
> 用户可以使用`JavaBean`将功能、处理、值、数据库访问和其他任何可以用`Java`代码创造的对象进行打包，并且其他的开发者可以通过内部的`JSP`页面、`Servlet`、其他`JavaBean`、`applet`程序或者应用来使用这些对象。用户可以认为`JavaBean`提供了一种随时随地的复制和粘贴的功能，而不用关心任何改变。

## 拓展：UML类图

![image.png](https://cdn.jsdelivr.net/gh/Lxzz24/IMG/repo/SE0410.png)

1. + 表示 public 类型， - 表示 private 类型，#表示protected类型
1. 方法的写法: 

方法的类型(+、-) 方法名(参数名： 参数类型)：返回值类型


# 4.9 关键字：this
## 1. this可以用来修饰、调用：属性、方法、构造器
 
## 2. this修饰属性和方法：
> **this理解为：当前对象  **或**  当前正在创建的对象**

**2.1 在类的方法中，我们可以使用"**`**this.属性**`**"或"**`**this.方法**`**"的方式，调用当前对象属性或方法。**
但是通常情况下，我们都省略"`this.`"。特殊情况下，如果方法的形参和类的属性同名时，我们必须显式的使用"`this.变量`"的方式，表明此变量是属性而非形参。
**2.2 在类的构造器中，我们可以使用"**`**this.属性**`**"或"**`**this.方法**`**"的方式，调用当前正在创建的对象属性或方法。**
但是通常情况下，我们都省略"`this.`"。特殊情况下，如果构造器的形参和类的属性同名时，我们必须显式的使用"`this.变量`"的方式，表明此变量是属性而非形参。
## 3. this调用构造器
① 我们在类的构造器中，可以显式的使用"`**this(形参列表)**`"方式，调用本类中指定的其他构造器
② 构造器中不能通过"`**this(形参列表)**`"方式调用自己
③ 如果一个类中有`n`个构造器，则最多有`n - 1`个构造器中使用了"`**this(形参列表)**`"
④ 规定："`**this(形参列表)**`"必须声明在当前构造器的首行
⑤ 构造器内部，最多只能声明一个"`**this(形参列表)**`"，用来调用其他构造器

# 4.10 关键字：package、import
## 一、package 关键字的使用

1. 为了更好的实现项目中类的管理，提供包的概念
1. 使用package声明类或接口所需的包，声明在源文件的首行
1. 包，属于标识符，遵循标识符的命名规则、规范（xxxyyyzzz）、“见名知意”
1. 每"."一次，就代表一层文件目录
> 补充： 
> 同一个包下，不能命名同名的接口、类；
> 不同的包下，可以命名同名的接口、类。

​

> **JDK中主要的包**
> 1. `**java.lang**`（language）----包含一些Java语言的核心类，如String、Math、Integer、 System和Thread，提供常用功能
> 2. `**java.net**`----包含执行与网络相关的操作的类和接口。
> 3. `**java.io**` ----包含能提供多种输入/输出功能的类。
> 4. `**java.util**`----包含一些实用工具类，如定义系统特性、接口的集合框架类、使用与日期日历相关的函数。
> 5. `**java.text**`----包含了一些java格式化相关的类
> 6. `**java.sql**`----包含了java进行JDBC数据库编程的相关类/接口
> 7. `**java.awt**`----包含了构成抽象窗口工具集（abstract window toolkits）的多个类，这些类被用来构建和管理应用程序的图形用户界面(GUI)。_~~（Java也可以写客户端，但是基本不用了）~~_



> **MVC设计模式**
> MVC是常用的设计模式之一，将整个程序分为三个层次：视图模型层，控制器层，与数据模型层。
> **模型层 model 主要处理数据**
> - 数据对象封装 model.bean/domain
> - 数据库操作类 model.dao
> - 数据库 model.db
> 
**视图层 view 显示数据**
> - 相关工具类 view.utils
> - 自定义view view.ui
> 
**控制层 controller 处理业务逻辑**
> - 应用界面相关 controller.activity
> - 存放fragment controller.fragment
> - 显示列表的适配器 controller.adapter
> - 服务相关的 controller.service
> - 抽取的基类 controller.base


**好处：**这种将程序输入输出、数据处理，以及数据的展示分离开来的设计模式使程序结构变的灵活而且清晰，同时也描述了程序各个对象间的通信方式，降低了程序的耦合性。

## 二、import 关键字的使用
import：导入

1. 在源文件中显式的使用import结构导入指定包下的类、接口
1. 声明在包的声明和类的声明之间
1. 如果需要导入多个结构，则并列写出即可
1. 可以使用"xxx.*"的方式，表示可以导入xxx包下的所有结构
1. 如果使用的类或接口是java.lang包下定义的，则可以省略import结构
1. 如果使用的类或接口是本包下定义的，则可以省略import结构
1. 如果在源文件中，使用了不同包下的同名的类，则必须至少有一个类以全类名的方式显示
1. 使用"xxx.*"方式表明可以调用xxx包下的所有结构。但是如果使用的是xxx子包下的结构，则仍需要显式导入。
1. import static：导入指定类或接口中的静态结构：属性或方法。

​

