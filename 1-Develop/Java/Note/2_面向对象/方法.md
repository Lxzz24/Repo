## 方法：*描述类应该具有的功能*

一个 `class` 可以包含多个 `field` ，例如，我们给 `Person` 类就定义了两个 `field` ：

```java
class Person {
    public String name;
    public int age;
}
```

但是，直接把 `field` 用 `public` 暴露给外部可能会破坏封装性。比如，代码可以这样写：

```java
    Person ming = new Person();
    ming.name = "Xiao Ming";
    ming.age = -99; // age设置为负数 
```

显然，直接操作 `field` ，容易造成逻辑混乱。为了避免外部代码直接去访问 `field` ，我们可以用 `private` 修饰 `field` ，拒绝外部访问：

```java
class Person {
    private String name;
    private int age;
}
```

试试 `private` 修饰的 `field` 有什么效果：

```java
public class Main {
    public static void main(String[] args) {
        Person ming = new Person();
        ming.name = "Xiao Ming"; // 对字段name赋值
        ming.age = 12; // 对字段age赋值
    }
}

class Person {
    private String name;
    private int age;
}
```

是不是编译报错？把访问 `field` 的赋值语句去了就可以正常编译了。



把 `field` 从 `public` 改成 `private` ，外部代码不能访问这些 `field` ，那我们定义这些 `field` 有什么用？怎么才能给它赋值？怎么才能读取它的值？

所以我们需要使用方法（ `method` ）来让外部代码可以间接修改 `field` ：

```java
public class Main {
    public static void main(String[] args) {
        Person ming = new Person();
        ming.setName("Xiao Ming"); // 设置name
        ming.setAge(12); // 设置age
        System.out.println(ming.getName() + ", " + ming.getAge());
    }
}

class Person {
    private String name;
    private int age;

    public String getName() {
        return this.name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public int getAge() {
        return this.age;
    }

    public void setAge(int age) {
        if (age < 0 || age > 100) {
            throw new IllegalArgumentException("invalid age value");
        }
        this.age = age;
    }
}
```

虽然外部代码不能直接修改 `private` 字段，但是，外部代码可以调用方法 `setName()` 和 `setAge()` 来间接修改 `private` 字段。在方法内部，我们就有机会检查参数对不对。比如， `setAge()` 就会检查传入的参数，参数超出了范围，直接报错。这样，外部代码就没有任何机会把 `age` 设置成不合理的值。

对 `setName()` 方法同样可以做检查，例如，不允许传入 `null` 和空字符串：

```java
public void setName(String name) {
    if (name == null || name.isBlank()) {
        throw new IllegalArgumentException("invalid name");
    }
    this.name = name.strip(); // 去掉首尾空格
}
```

同样，外部代码不能直接读取 `private` 字段，但可以通过 `getName()` 和 `getAge()` 间接获取 `private` 字段的值。

所以，*一个类通过定义方法，就可以给外部代码暴露一些操作的接口，同时，内部自己保证逻辑一致性* 。

调用方法的语法是 `实例变量.方法名(参数);` 。一个方法调用就是一个语句，所以不要忘了在末尾加 `;` 。例如： `ming.setName("Xiao Ming");` 。


## 定义方法

从上面的代码可以看出，定义方法的语法是：

```java
权限修饰符 返回值类型 方法名( 形参列表 ){
	方法体
	//return 返回值;
}
```

方法返回值通过 `return` 语句实现，如果没有返回值，返回类型设置为 `void` ，可以省略 `return` 。

举例：
```java
public void eat(){}
public void sleep(int hour){}
public String getName(){}
public String getNation(String nation){}
```

## 说明

1. 关于权限修饰符，默认方法的权限修饰符先都使用 `public`
   - Java 中规定的权限修饰符：private、public、缺省、protected → [封装性](/1-Develop/Java/Note/2_面向对象/封装性.md) 再细说  
2. 返回值类型： 有返回值 vs	无返回值
   - 如果方法*有返回值*，则必须再方法声明时，指定返回值的类型。同时，方法中，需要使用 `return` 关键字来返回指定类型的变量或者常量；
   - 如果方法*没有返回值*，则方法声明时，使用 `void` 来表示。通常，没有返回值的方法中，就不需要使用`return` 。但是，如果使用的话，只能 `return;` 表示结束此方法的意思。
   - 我们定义方法该不该有返回值？
     - ① 题目要求； ② 凭经验，具体问题具体分析；
3. 方法名：属于标识符，遵循标识符的规则和规范：“见名知意”
4. 形参列表： 方法可以声明 0 个、1 个、或多个形参。
   1. 格式：`数据类型1 形参1, 数据类型2 形参2, ...`
   2. 我们定义方法时，该不该定义形参？
      - ① 题目要求；② 凭经验，具体问题具体分析；
5. 方法体：方法功能的体现。


***方法的使用中，可以调用当前类的属性或方法***


特殊的，方法 A 中又调用了方法 A ：递归方法（例如快速排序）。  

!> 方法中，不可以定义方法。


## 分类


![](https://cdn.gxmnzl.xyz//img/20220531231036.png)


## return 关键字

1. 使用范围：  
   使用在方法体中。
2. 作用：  
    ① 结束方法；  
    ② 针对于有返回值类型的方法，使用 `return 数据` 方法返回所要的数据。  
3. 注意点：  
    return 关键字后面不可以声明执行语句。


## 可变个数形参的方法


1. 可变个数形参的格式：数据类型 ... 变量名
2. 当调用可变个数形参的方法时，传入的参数个数可以是：0个，1个，2个...
3. 可变个数形参的方法与本类中方法名相同，形参不同的方法之间构成重载
4. 可变个数形参的方法与本类中方法名相同，形参类型也相同的数组之间，不构成重载
5. 可变个数形参在方法的形参中，必须声明在（形参列表的）末尾
6. 可变个数形参在方法的形参中，最多只能声明一个可变形参

```java
	public void show(int i){
		System.out.println("show(int i)");
	}
	public void show(String s){
		System.out.println("show(String s)");
	}
	public void show(String ... strs){
		System.out.println("show(String ... strs)");
		for(int i = 0;i < strs.length;i++){
			System.out.println(strs[i]);
		}
	}
	
	//不能与上一个方法同时存在
//	public void show(String[] str){
//		
//	}
```


## 方法参数的值传递机制

![image.png](https://cdn.gxmnzl.xyz/img/SE0404.png)

![image.png](https://cdn.gxmnzl.xyz/img/SE0405.png)

- ***形参***：方法 *定义* 时，*声明的小括号内的参数* ；
- ***实参***：方法 *调用* 时，*实际传递给形参的数据* ；

?> Java中参数传递机制：值传递

- 如果参数是 *基本数据类型* ，此时实参赋给形参的是，实参真实存储的 *数据值* 。
- 如果参数是 *引用数据类型* ，此时实参赋给形参的是，实参存储数据的 *地址值* 。

## 关于变量的赋值

- 如果变量是 *基本数据类型* ，此时赋值的是变量所保存的 *数据值* 。
- 如果变量是 *引用数据类型* ，此时赋值的是变量所保存的数据的 *地址值* 。


```java
public class ValueTransferTest {
	public static void main(String[] args) {
		String s1 = "hello";
		
		ValueTransferTest test = new ValueTransferTest();
		test.change(s1);
		
		System.out.println(s1);//hello
	}
	
	public void change(String s){
		s = "hi~~";
	}
}
```

![image.png](https://cdn.gxmnzl.xyz/img/SE0406.png)


## 递归方法（了解）

?> 一个方法体内调用它自身

- 方法递归包含了一种隐式的循环，它会重复执行某段代码，但这种重复执行无须循环控制。
- 递归一定要向已知方向递归，否则这种递归就变成了无穷递归，类似于死循环。


```java
public class RecursionTest {
	
	public static void main(String[] args) {
		
		//例1. 计算1 ~ 100之间所有自然数的和
		//方式一：
		int sum = 0;
		for(int i = 0;i <= 100;i++){
			sum += i;
		}
		System.out.println(sum);
		
		//方式二：
		RecursionTest test = new RecursionTest();
		int sum1 = test.getSum(100);
		System.out.println(sum1);
		
	}
	
	//例1. 计算1 ~ n之间所有自然数的和
	public int getSum(int n){
		
		if(n == 1){
			return 1;
		}else{
			return n + getSum(n - 1);
		}
		
	}
	
	//例2. 计算1 ~ n之间所有自然数的乘积：阶乘n!
	public int getSum1(int n){
			
		if(n == 1){
			return 1;
		}else{
			return n * getSum1(n - 1);
		}
			
	}
		
	//例3. 7.2 f(0) = 1, f(1) = 4, f(n+2) = 2 * f(n+1) + f(n)
	public int getFx1(int n){
        if(n == 0){
            return 1;
        }else if(n == 1){
            return 4;
        }else{
//			return 2 * getFx1(n + 2) - getFx1(n + 1);
            return 2 * getFx1(n - 1) + getFx1(n - 2);
        }
    }
    
	//例4. 斐波那契数列(Fibonacci)
	public int getFibonacci(int n){
		if(n == 1 || n == 2){
			return 1;
		}else{
			return getFibonacci(n-1) + getFibonacci(n-2);
		}
	}
	//例5. 汉诺塔问题
		
	//例6. 快速排序
}
```


## 扩展：

![image.png](https://cdn.gxmnzl.xyz/img/SE0407.png)

![image.png](https://cdn.gxmnzl.xyz/img/SE0408.png)
