## 方法：*描述类应该具有的功能*

比如： 
- Math 类：	`sqrt()\ random()\...`
- Scanner 类：	`nextXxx();`
- Arrays 类：	`sort()\ binarySearch()\ toString()\ equals()\...`

## 语法格式

```java
权限修饰符 返回值类型 方法名( 形参列表 ){
	方法体
	//return 返回值;
}
```

举例：
```java
public void eat(){}
public void sleep(int hour){}
public String getName(){}
public String getNation(String nation){}
```

## 说明

1. 关于权限修饰符，默认方法的权限修饰符先都使用 `public`
   - Java 中规定的权限修饰符：private、public、缺省、protected → [封装性](/1-Develop/Java/Note/2_面向对象/封装性.md) 再细说  
2. 返回值类型： 有返回值 vs	无返回值
   - 如果方法*有返回值*，则必须再方法声明时，指定返回值的类型。同时，方法中，需要使用 `return` 关键字来返回指定类型的变量或者常量；
   - 如果方法*没有返回值*，则方法声明时，使用 `void` 来表示。通常，没有返回值的方法中，就不需要使用`return` 。但是，如果使用的话，只能 `return;` 表示结束此方法的意思。
   - 我们定义方法该不该有返回值？
     - ① 题目要求； ② 凭经验，具体问题具体分析；
3. 方法名：属于标识符，遵循标识符的规则和规范：“见名知意”
4. 形参列表： 方法可以声明 0 个、1 个、或多个形参。
   1. 格式：`数据类型1 形参1, 数据类型2 形参2, ...`
   2. 我们定义方法时，该不该定义形参？
      - ① 题目要求；② 凭经验，具体问题具体分析；
5. 方法体：方法功能的体现。


***方法的使用中，可以调用当前类的属性或方法***


特殊的，方法 A 中又调用了方法 A ：递归方法（例如快速排序）。  

!> 方法中，不可以定义方法。


## 分类


![](https://cdn.gxmnzl.xyz//img/20220531231036.png)


## return 关键字

1. 使用范围：  
   使用在方法体中。
2. 作用：  
    ① 结束方法；  
    ② 针对于有返回值类型的方法，使用 `return 数据` 方法返回所要的数据。  
3. 注意点：  
    return 关键字后面不可以声明执行语句。


## 可变个数形参的方法


1. 可变个数形参的格式：数据类型 ... 变量名
2. 当调用可变个数形参的方法时，传入的参数个数可以是：0个，1个，2个...
3. 可变个数形参的方法与本类中方法名相同，形参不同的方法之间构成重载
4. 可变个数形参的方法与本类中方法名相同，形参类型也相同的数组之间，不构成重载
5. 可变个数形参在方法的形参中，必须声明在（形参列表的）末尾
6. 可变个数形参在方法的形参中，最多只能声明一个可变形参

```java
	public void show(int i){
		System.out.println("show(int i)");
	}
	public void show(String s){
		System.out.println("show(String s)");
	}
	public void show(String ... strs){
		System.out.println("show(String ... strs)");
		for(int i = 0;i < strs.length;i++){
			System.out.println(strs[i]);
		}
	}
	
	//不能与上一个方法同时存在
//	public void show(String[] str){
//		
//	}
```


## 方法参数的值传递机制

![image.png](https://cdn.gxmnzl.xyz/img/SE0404.png)

![image.png](https://cdn.gxmnzl.xyz/img/SE0405.png)

- ***形参***：方法 *定义* 时，*声明的小括号内的参数* ；
- ***实参***：方法 *调用* 时，*实际传递给形参的数据* ；

?> Java中参数传递机制：值传递

- 如果参数是 *基本数据类型* ，此时实参赋给形参的是，实参真实存储的 *数据值* 。
- 如果参数是 *引用数据类型* ，此时实参赋给形参的是，实参存储数据的 *地址值* 。

## 关于变量的赋值

- 如果变量是 *基本数据类型* ，此时赋值的是变量所保存的 *数据值* 。
- 如果变量是 *引用数据类型* ，此时赋值的是变量所保存的数据的 *地址值* 。


```java
public class ValueTransferTest {
	public static void main(String[] args) {
		String s1 = "hello";
		
		ValueTransferTest test = new ValueTransferTest();
		test.change(s1);
		
		System.out.println(s1);//hello
	}
	
	public void change(String s){
		s = "hi~~";
	}
}
```

![image.png](https://cdn.gxmnzl.xyz/img/SE0406.png)


## 递归方法（了解）

?> 一个方法体内调用它自身

- 方法递归包含了一种隐式的循环，它会重复执行某段代码，但这种重复执行无须循环控制。
- 递归一定要向已知方向递归，否则这种递归就变成了无穷递归，类似于死循环。


```java
public class RecursionTest {
	
	public static void main(String[] args) {
		
		//例1. 计算1 ~ 100之间所有自然数的和
		//方式一：
		int sum = 0;
		for(int i = 0;i <= 100;i++){
			sum += i;
		}
		System.out.println(sum);
		
		//方式二：
		RecursionTest test = new RecursionTest();
		int sum1 = test.getSum(100);
		System.out.println(sum1);
		
	}
	
	//例1. 计算1 ~ n之间所有自然数的和
	public int getSum(int n){
		
		if(n == 1){
			return 1;
		}else{
			return n + getSum(n - 1);
		}
		
	}
	
	//例2. 计算1 ~ n之间所有自然数的乘积：阶乘n!
	public int getSum1(int n){
			
		if(n == 1){
			return 1;
		}else{
			return n * getSum1(n - 1);
		}
			
	}
		
	//例3. 7.2 f(0) = 1, f(1) = 4, f(n+2) = 2 * f(n+1) + f(n)
	public int getFx1(int n){
        if(n == 0){
            return 1;
        }else if(n == 1){
            return 4;
        }else{
//			return 2 * getFx1(n + 2) - getFx1(n + 1);
            return 2 * getFx1(n - 1) + getFx1(n - 2);
        }
    }
    
	//例4. 斐波那契数列(Fibonacci)
	public int getFibonacci(int n){
		if(n == 1 || n == 2){
			return 1;
		}else{
			return getFibonacci(n-1) + getFibonacci(n-2);
		}
	}
	//例5. 汉诺塔问题
		
	//例6. 快速排序
}
```


## 扩展：

![image.png](https://cdn.gxmnzl.xyz/img/SE0407.png)

![image.png](https://cdn.gxmnzl.xyz/img/SE0408.png)
