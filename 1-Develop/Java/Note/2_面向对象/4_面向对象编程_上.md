






# 4.6 再谈方法
## 方法的重载
定义
> 在同一个类中，允许存在一个以上的同名方法，只要它们的参数列表(参数个数或参数类型)不同即可。

> **“两同一不同”：**	
> 1. 同一个类、相同方法名
> 1. 参数列表不同：参数个数不同，参数类型不同

举例：
> `Arrays` 类中重载的 `sort()` / `binarySearch()`

```java
	//如下的4个方法就构成了重载
	public void getSum(int i, int j) {
		System.out.println("1");
	}

	public void getSum(double d1, double d2) {
		System.out.println("2");
	}

	public void getSum(String s,int i) {
		System.out.println("3");
	}
	public void getSum(int i,String s) {
		System.out.println("4");
	}
```
判断：
> 跟方法的权限修饰符、返回值类型、形参变量名、方法体都没有关系！

在通过对象调用方法时，**如何确定某一个指定的方法**
> 方法名 ---> 参数列表

面试题：方法的重载与重写的区别？
`throws` \ `throw`
`String` \ `StringBuffer` \ `StringBuilder`
`Collection` \ `Collections`
`final` \ `finally` \ `finalize`
...
抽象类、接口
`sleep()`  /  `wait()`




- 
# 4.8 类的成员之三：构造器
construct：建设、建造。	
constructor：建设者。
## 一、构造器的作用：

1. 创建对象
1. 初始化对象的属性
## 二、使用说明：

1. 如果没有显式的定义类的构造器的话，则系统默认提供一个空参的构造器；
1. 定义构造器的格式：`权限修饰符  类名（形参列表）{}`
1. 一个类中定义的多个构造器，彼此构成重载；
1. 一旦我们显式的定义了类的构造器之后，系统就不再提供默认的空参构造器；
1. 一个类中，至少会有一个构造器。
## 三、总结：属性赋值的先后顺序
① 默认初始化值
② 显式初始化
③ 构造器中赋值
④ 通过"对象.方法"或"对象.属性"的方式，赋值
以上操作的先后顺序：① -> ② -> ③ -> ④

## 拓展：JavaBean
> 是一种Java语言写成的可重用组件。

所谓 `JavaBean` ，是指符合如下标准的Java类：

- 类是公共的
- 有一个无参的公共的构造器
- 有属性，且有对应的get、set方法
> 用户可以使用`JavaBean`将功能、处理、值、数据库访问和其他任何可以用`Java`代码创造的对象进行打包，并且其他的开发者可以通过内部的`JSP`页面、`Servlet`、其他`JavaBean`、`applet`程序或者应用来使用这些对象。用户可以认为`JavaBean`提供了一种随时随地的复制和粘贴的功能，而不用关心任何改变。

## 拓展：UML类图

![image.png](https://cdn.gxmnzl.xyz/img/SE0410.png)

1. + 表示 public 类型， - 表示 private 类型，#表示protected类型
1. 方法的写法: 

方法的类型(+、-) 方法名(参数名： 参数类型)：返回值类型


# 4.9 关键字：this
## 1. this可以用来修饰、调用：属性、方法、构造器
 
## 2. this修饰属性和方法：
> **this理解为：当前对象  **或**  当前正在创建的对象**

**2.1 在类的方法中，我们可以使用"**`**this.属性**`**"或"**`**this.方法**`**"的方式，调用当前对象属性或方法。**
但是通常情况下，我们都省略"`this.`"。特殊情况下，如果方法的形参和类的属性同名时，我们必须显式的使用"`this.变量`"的方式，表明此变量是属性而非形参。
**2.2 在类的构造器中，我们可以使用"**`**this.属性**`**"或"**`**this.方法**`**"的方式，调用当前正在创建的对象属性或方法。**
但是通常情况下，我们都省略"`this.`"。特殊情况下，如果构造器的形参和类的属性同名时，我们必须显式的使用"`this.变量`"的方式，表明此变量是属性而非形参。
## 3. this调用构造器
① 我们在类的构造器中，可以显式的使用"`**this(形参列表)**`"方式，调用本类中指定的其他构造器
② 构造器中不能通过"`**this(形参列表)**`"方式调用自己
③ 如果一个类中有`n`个构造器，则最多有`n - 1`个构造器中使用了"`**this(形参列表)**`"
④ 规定："`**this(形参列表)**`"必须声明在当前构造器的首行
⑤ 构造器内部，最多只能声明一个"`**this(形参列表)**`"，用来调用其他构造器

# 4.10 关键字：package、import
## 一、package 关键字的使用

1. 为了更好的实现项目中类的管理，提供包的概念
1. 使用package声明类或接口所需的包，声明在源文件的首行
1. 包，属于标识符，遵循标识符的命名规则、规范（xxxyyyzzz）、“见名知意”
1. 每"."一次，就代表一层文件目录
> 补充： 
> 同一个包下，不能命名同名的接口、类；
> 不同的包下，可以命名同名的接口、类。

​

> **JDK中主要的包**
> 1. `**java.lang**`（language）----包含一些Java语言的核心类，如String、Math、Integer、 System和Thread，提供常用功能
> 2. `**java.net**`----包含执行与网络相关的操作的类和接口。
> 3. `**java.io**` ----包含能提供多种输入/输出功能的类。
> 4. `**java.util**`----包含一些实用工具类，如定义系统特性、接口的集合框架类、使用与日期日历相关的函数。
> 5. `**java.text**`----包含了一些java格式化相关的类
> 6. `**java.sql**`----包含了java进行JDBC数据库编程的相关类/接口
> 7. `**java.awt**`----包含了构成抽象窗口工具集（abstract window toolkits）的多个类，这些类被用来构建和管理应用程序的图形用户界面(GUI)。_~~（Java也可以写客户端，但是基本不用了）~~_



> **MVC设计模式**
> MVC是常用的设计模式之一，将整个程序分为三个层次：视图模型层，控制器层，与数据模型层。
> **模型层 model 主要处理数据**
> - 数据对象封装 model.bean/domain
> - 数据库操作类 model.dao
> - 数据库 model.db
> 
**视图层 view 显示数据**
> - 相关工具类 view.utils
> - 自定义view view.ui
> 
**控制层 controller 处理业务逻辑**
> - 应用界面相关 controller.activity
> - 存放fragment controller.fragment
> - 显示列表的适配器 controller.adapter
> - 服务相关的 controller.service
> - 抽取的基类 controller.base


**好处：**这种将程序输入输出、数据处理，以及数据的展示分离开来的设计模式使程序结构变的灵活而且清晰，同时也描述了程序各个对象间的通信方式，降低了程序的耦合性。

## 二、import 关键字的使用
import：导入

1. 在源文件中显式的使用import结构导入指定包下的类、接口
1. 声明在包的声明和类的声明之间
1. 如果需要导入多个结构，则并列写出即可
1. 可以使用"xxx.*"的方式，表示可以导入xxx包下的所有结构
1. 如果使用的类或接口是java.lang包下定义的，则可以省略import结构
1. 如果使用的类或接口是本包下定义的，则可以省略import结构
1. 如果在源文件中，使用了不同包下的同名的类，则必须至少有一个类以全类名的方式显示
1. 使用"xxx.*"方式表明可以调用xxx包下的所有结构。但是如果使用的是xxx子包下的结构，则仍需要显式导入。
1. import static：导入指定类或接口中的静态结构：属性或方法。

​

