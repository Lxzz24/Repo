Java 的整数运算遵循四则运算规则，可以使用任意嵌套的小括号。四则运算规则和初等数学一致。例如：

```java
//四则运算
public class Main {
    public static void main(String[] args) {
        int i = (100 + 200) * (99 - 88); // 3300
        int n = 7 * (5 + (i - 9)); // 23072
        System.out.println(i);
        System.out.println(n);
    }
}
```

整数的数值表示不但是精确的，而且整数运算永远是精确的，即使是除法也是精确的，因为两个整数相除只能得到结果的整数部分：

```java
    int x = 12345 / 67; // 184
```

求余运算使用 `%` ：

```java
    int y = 12345 % 67; // 12345 ÷ 67 的余数是17
```

> [!ATTENTION]
> **整数的除法对于除数为 0 时运行时将报错，但编译不会报错。**


## 溢出

要特别注意，整数由于存在范围限制，如果计算结果超出了范围，就会产生溢出，而溢出不会出错，却会得到一个奇怪的结果：

```java
// 运算溢出
public class Main {
    public static void main(String[] args) {
        int x = 2147483640;
        int y = 15;
        int sum = x + y;
        System.out.println(sum); // -2147483641
    }
}
```

要解释上述结果，我们把整数 `2147483640` 和 `15` 换成二进制做加法：


![](https://cdn.gxmnzl.xyz//img/202206011637247.png)


由于最高位计算结果为 `1`，因此，加法结果变成了一个负数。

要解决上面的问题，可以把 `int` 换成 `long` 类型，由于 `long` 可表示的整型范围更大，所以结果就不会溢出：

```java
    long x = 2147483640;
    long y = 15;
    long sum = x + y;
    System.out.println(sum); // 2147483655
```

还有一种简写的运算符，即 `+=`，`-=`，`*=`，`/=`，它们的使用方法如下：

```java
    n += 100; // 3409, 相当于 n = n + 100;
    n -= 100; // 3309, 相当于 n = n - 100;
```

## 自增/自减

Java 还提供了 `++` 运算和 `--` 运算，它们可以对一个整数进行加 1 和减 1 的操作：

```java
// 自增/自减运算
public class Main {
    public static void main(String[] args) {
        int n = 3300;
        n++; // 3301, 相当于 n = n + 1;
        n--; // 3300, 相当于 n = n - 1;
        int y = 100 + (++n); // 不要这么写
        System.out.println(y);
    }
}
```


注意 `++` 写在前面和后面计算结果是不同的，`++n` 表示先加 1 再引用 n，`n++` 表示先引用 n 再加 1。不建议把 `++` 运算混入到常规运算中，容易自己把自己搞懵了。


## 移位运算

在计算机中，整数总是以二进制的形式表示。例如，`int` 类型的整数 `7` 使用 4 字节表示的二进制如下：

00000000 0000000 0000000 00000111

可以对整数进行移位运算。对整数 `7` 左移 `1` 位将得到整数 `14`，左移两位将得到整数 `28`：

```java
    int n = 7;       // 00000000 00000000 00000000 00000111 = 7
    int a = n << 1;  // 00000000 00000000 00000000 00001110 = 14
    int b = n << 2;  // 00000000 00000000 00000000 00011100 = 28
    int c = n << 28; // 01110000 00000000 00000000 00000000 = 1879048192
    int d = n << 29; // 11100000 00000000 00000000 00000000 = -536870912
```

左移 29 位时，由于最高位变成 `1`，因此结果变成了负数。

类似的，对整数 `28` 进行右移，结果如下：

```java
    int n = 7;       // 00000000 00000000 00000000 00000111 = 7
    int a = n >> 1;  // 00000000 00000000 00000000 00000011 = 3
    int b = n >> 2;  // 00000000 00000000 00000000 00000001 = 1
    int c = n >> 3;  // 00000000 00000000 00000000 00000000 = 0
```

如果对一个负数进行右移，最高位的 `1` 不动，结果仍然是一个负数：

```java
    int n = -536870912;
    int a = n >> 1;  // 11110000 00000000 00000000 00000000 = -268435456
    int b = n >> 2;  // 11111000 00000000 00000000 00000000 = -134217728
    int c = n >> 28; // 11111111 11111111 11111111 11111110 = -2
    int d = n >> 29; // 11111111 11111111 11111111 11111111 = -1
```

还有一种无符号的右移运算，使用 `>>>`，它的特点是不管符号位，右移后高位总是补 `0`，因此，对一个负数进行 `>>>` 右移，它会变成正数，原因是最高位的 `1` 变成了 `0`：

```java
    int n = -536870912;
    int a = n >>> 1;  // 01110000 00000000 00000000 00000000 = 1879048192
    int b = n >>> 2;  // 00111000 00000000 00000000 00000000 = 939524096
    int c = n >>> 29; // 00000000 00000000 00000000 00000111 = 7
    int d = n >>> 31; // 00000000 00000000 00000000 00000001 = 1
```

对 `byte` 和 `short` 类型进行移位时，会首先转换为 `int` 再进行位移。

仔细观察可发现，左移实际上就是不断地乘 2，右移实际上就是不断地除以 2。


## 位运算

位运算是按位进行 *与* 、*或* 、*非* 和 *异或* 的运算。

***与运算*** 的规则是，必须两个数同时为 `1`，结果才为 `1`：

```java
n = 0 & 0; // 0
n = 0 & 1; // 0
n = 1 & 0; // 0
n = 1 & 1; // 1
```

***或运算*** 的规则是，只要任意一个为 `1`，结果就为 `1`：

```java
n = 0 | 0; // 0
n = 0 | 1; // 1
n = 1 | 0; // 1
n = 1 | 1; // 1
```

***非运算*** 的规则是，`0` 和 `1` 互换：

```java
n = ~0; // 1
n = ~1; // 0
```

***异或运算*** 的规则是，如果两个数不同，结果为 `1`，否则为 `0`：

```java
n = 0 ^ 0; // 0
n = 0 ^ 1; // 1
n = 1 ^ 0; // 1
n = 1 ^ 1; // 0
```

***对两个整数进行位运算，实际上就是按位对齐，然后依次对每一位进行运算。*** 例如：

```java
// 位运算
public class Main {
    public static void main(String[] args) {
        int i = 167776589; // 00001010 00000000 00010001 01001101
        int n = 167776512; // 00001010 00000000 00010001 00000000
        System.out.println(i & n); // 167776512
    }
}
```

上述按位与运算实际上可以看作两个整数表示的 IP 地址 `10.0.17.77` 和 `10.0.17.0` ，通过与运算，可以快速判断一个 IP 是否在给定的网段内。




## 小结

整数运算的结果永远是精确的；

运算结果会自动提升；

可以强制转型，但超出范围的强制转型会得到错误的结果；

应该选择合适范围的整型（ int 或 long ），没有必要为了节省内存而使用 byte 和 short 进行整数运算。


## 练习

计算前 N 个自然数的和可以根据公式：

$\frac{(1+N)\times N}2 $

​请根据公式计算前N个自然数的和：


```java
// 计算前N个自然数的和
public class SumTest {
    public static void main(String[] args) {
        int n = 100;
        
        // TODO: sum = 1 + 2 + ... + n
        int sum = 0;

        for (int i = 0; i <= n; i++){
            sum += i;
        }

        System.out.println(sum);//5050
        System.out.println(sum == 5050 ? "测试通过" : "测试失败");
    }
}
```
