# 进制：

所有数字在计算机底层都以二进制形式存在。

![](https://cdn.gxmnzl.xyz//img/20220529224813.png)


## 对于整数，有四种表示方式： 

- *二进制* (binary)：0，1 ，满 2 进 1。 以 0b 或 0B 开头。 
- *十进制* (decimal)：0 - 9 ，满 10 进 1。 
- *八进制* (octal)：0 - 7 ，满 8 进 1。 以数字 0 开头表示。 
- *十六进制* (hex)：0 - 9 及 A - F，满 16 进 1。 以 0x 或 0X 开头表示。
  - 此处的 A - F 不区分大小写。如：`0x21AF + 1 = 0X21B0`

> [!TIP]
> - 原码：直接将一个数值换成二进制数。最高位是符号位;  
> - 负数的反码：是对原码按位取反，只是最高位（符号位）确定为 1;  
> - 负数的补码：其反码加 1。  


!> *计算机底层都以补码的方式来存储数据！*

- +127：
  - 0111 1111
- -127：
  - 1111 1111 原码
  - 1000 0000 反码
  - 1000 0001 补码
- -128：
  - 1000 0000 补码

$$(-1) + (-127) = [1000 0001]原 + [1111 1111]原 = [1111 1111]补 + [1000 0001]补 = [1000 0000]补$$

> [!ATTENTION]
> -1-127 的结果应该是 -128, 在用补码运算的结果中, [1000 0000]补 就是 -128.
> 但是注意因为实际上是使用以前的 -0 的补码来表示 -128，所以 -128 并没有原码和反码表示，
> (对 -128 的补码表示 *[1000 0000]补* 算出来的原码是 *[0000 0000]原*，这是不正确的)，
> 使用补码，不仅仅修复了 0 的符号以及存在两个编码的问题，而且还能够多表示一个最低数。
> 这就是为什么 8 位二进制，使用原码或反码表示的范围为 [-127, +127]，
> 而使用补码表示的范围为 [-128, 127]。


## 进制间的转换

- 十进制 → 二进制 ：
  - *除二取余的逆*
- 二进制 → 八进制 ：
  - *每 3 个一位*
- 二进制 → 十六进制	：
  - *每 4 个一位*


> [!NOTE]
> 开发过程中： 	
> - `toBinaryString(int i);`
> - `toOctalString(int i);`					
> - `toHexString(int i);`

