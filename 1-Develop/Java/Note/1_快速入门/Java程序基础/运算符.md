## 算术运算符 

`+`(正)、 `-`(负)、 `+`、 `-`、 `*`、 `/`

- `%` : 取余（模）运算
  - 结果的符号与被模数的符号相同
  - 开发中，经常使用 % 来判断能否被除尽的情况
- `(前)++` : 先自增 1，后再运算
- `(后)++` : 先运算，后自增 1 


> [!ATTENTION]
> 注意点：自增 1 不会改变本身变量的数据类型


```java
  //问题:
  byte bb1 = 127;
  bb1++;
  System.out.println("bb1 = " + bb1); //-128,溢出
```

- `(前)--` 先自减 1，后再运算
- `(后)--` 先运算，后自减 1


## 赋值运算符

`=`  

扩展赋值运算符：`+=`，`-=`，`*=`，`/=`，`%=`

## 比较运算符（关系运算符）

|    运算符    |        运算        |           范例            | 结果  |
| :----------: | :----------------: | :-----------------------: | :---: |
|     `==`     |       相等于       |          4 == 3           | false |
|     `!=`     |       不等于       |          4 != 3           | true  |
|     `<`      |        小于        |           4 < 3           | false |
|     `>`      |        大于        |           4 > 3           | true  |
|     `<=`     |      小于等于      |          4 <= 3           | false |
|     `>=`     |      大于等于      |          4 >= 3           | true  |
| `instanceof` | 检查是否是类的对象 | "Hello" instanceof String | true  |

> [!TIP]
> 1. 比较运算符的结果是 boolean 类型
> 2. 区分 `==` 和 `=`

## 逻辑运算符
`&`	逻辑与 		`|`	逻辑或 		`!`	逻辑非  
`&&`	短路与 		`||`	短路或 		`^`	逻辑异或	

![image.png](https://cdn.gxmnzl.xyz/img/SE0215.png)

> [!NOTE]
> 区分： **&** 与 **&&**
> - 相同点1：运算结果相同
> - 相同点2：当符号左边是 true 时，二者都会执行符号右边的运算
> - 不同点：当符号左边时 false 时，`&` 继续执行符号右边的运算。`&&` 不再执行符号右边的运算
> - 开发中，推荐使用 `&&` 。

> [!NOTE]
> 区分： **|** 与 **||**	
> - 相同点1：运算结果相同
> - 相同点2：当符号左边是 false 时，二者都会执行符号右边的运算
> - 不同点：当符号左边时 true 时，`|` 继续执行符号右边的运算。`||` 不再执行符号右边的运算。
> - 开发中，推荐使用 `||` 。	

## 位运算符
| 运算符 |    运算    |              范例              | 细节                                                                                         |
| :----: | :--------: | :----------------------------: | -------------------------------------------------------------------------------------------- |
|  `<<`  |    左移    | 3 << 2 = 12 --> 3 * 2 * 2 = 12 | 空位补0，被移除的高位丢弃，空缺位补0。                                                       |
|  `>>`  |    右移    |    3 >> 1 = 1 --> 3 / 2 = 1    | 被移位的二进制最高位是0，右移后，空缺位补0；最高位是1，空缺位补1。                           |
| `>>>`  | 无符号右移 |   3 >>> 1 = 1 --> 3 / 2 = 1    | 被移位二进制最高位无论是0或是1，空缺位都用0补。                                              |
|  `&`   |   与运算   |           6 & 3 = 2            | 二进制位进行&运算，只有1&1时结果是1，否则是0；                                               |
|   `    |     `      |             或运算             | 6                                                                                            | 3 = 7 | 二进制位进行 | 运算，只有0 | 0时结果是0，否则是1； |
|  `^`   |  异或运算  |           6 ^ 3 = 5            | 相同二进制位进行^运算，结果是0： 1^1=0,0^0=0；不相同二进制位进行^运算结果是1： 1^0=1,0^1=1； |
|  `~`   |  取反运算  |            ~6 = -7             | 正数取反，各二进制码按补码各位取反；负数取反，各二进制码按补码各位取反；                     |

> 结论：
> 1. 位运算符操作的都是整型的数据
> 2. `<<`：在一定范围内，每向左移一位，相当于 * 2
> 3. `>>`：在一定范围内，每向右移一位，相当于 / 2

$m = k ^ n = (m ^ n) ^ n$

## 三元运算符

### 1 结构： 

!> $(条件表达式) ? 表达式 1 : 表达式 2$

### 2 说明：

1. 条件表达式的结果为 boolean 类型
2. 根据条件表达式真或假，决定执行表达式 1，还是表达式 2.
	- 如果表达式为 true，则执行表达式 1；
	- 如果表达式为 false，则执行表达式 2；
3. 表达式 1 和表达式 2 要求是一致的。
4. 三元运算符可以嵌套使用

> [!NOTE]
> - 凡是可以使用三元运算符的地方，都可以改写为 if-else ：反之，不成立。
> - 如果程序既可以使用三元运算符，又可以使用 if-else 结构，那么优先选择三元运算符。
> - 简洁、执行效率高。


## 运算符的优先级

![image.png](https://cdn.gxmnzl.xyz/img/SE0216.png)