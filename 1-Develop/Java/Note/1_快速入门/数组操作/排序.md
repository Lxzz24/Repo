## ④ 数组元素的排序算法

**排序** ：

假设含有 n 个记录的序列为 $\{R_1,R_2,...,R_n\}$，其相应的关键字序列为 $\{K_1,K_2,...,K_n\}$。  

将这些记录重新排序为 $\{R_{i1},R_{i2},...,R_{in}\}$，使得相应的关键字值满足条 $K_{i1}<=K_{i2}<=...<=K_{in}$，这样的一种操作称为排序。

?> 通常来说，排序的目的是快速查找。


### 衡量排序算法的优劣：

1. **时间复杂度**：分析关键字的比较次数和记录的移动次数
2. **空间复杂度**：分析排序算法中需要多少辅助内存
3. **稳定性**：若两个记录A和B的关键字值相等，但排序后A、B的先后次序保持不变，则称这种排序算法是稳定的。

### 排序算法分类：

- *内部排序* ：
  整个排序过程不需要借助于外部存储器（如磁盘等），所有排序操作都在内存中完成。
- *外部排序* ：
  参与排序的数据非常多，数据量非常大，计算机无法把整个排序过程放在内存中完成，
  必须借助于外部存储器（如磁盘）。外部排序最常见的是多路归并排序。可以认为外部排序是由多次内部排序组成。

### 十大内部排序算法

- 选择排序
   - 直接选择排序、堆排序
- 交换排序
   - 冒泡排序、快速排序
- 插入排序
   - 直接插入排序、折半插入排序、Shell排序
- 归并排序
- 桶式排序
- 基数排序

详见 [排序算法图解](/2-PCbase/AlgorithmDataStructures/Note/sort.md)

#### 算法的5大特征

|                                 |                                                                                      |
| :-----------------------------: | ------------------------------------------------------------------------------------ |
|          *输入(Input)*          | 有 0 个或多个输入数据，这些输入必须有清楚的描述和定义                                |
|         *输出(Output)*          | 至少有 1 个或多个输出结果，不可以没有输出结果                                        |
|  *有穷性(有限性，Finiteness)*   | 算法在有限的步骤之后会自动结束而不会无限循环，并且每一个步骤可以在可接受的时间内完成 |
| *确定性(明确性，Definiteness)*  | 算法中的每一步都有确定的含义，不会出现二义性                                         |
| *可行性(有效性，Effectiveness)* | 算法的每一步都是清楚且可行的，能让用户用纸笔计算而求出答案                           |

### **冒泡排序**

冒泡排序的原理非常简单，它重复地走访过要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来。

#### 基本思想：

1. 比较相邻的元素。如果第一个比第二个大（升序），就交换他们两个。
2. 对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。
3. 针对所有的元素重复以上的步骤，除了最后一个。
4. 持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较为止。

#### 具体过程：

若序列中有 n 个元素，通常进行 n - 1 趟。  
- 第 1 趟，针对第 R[1] 至 R[n] 个元素进行。  
- 第 2 趟，针对第 R[1] 至 R[n－1] 个元素进行。  
- …… 第 n-1 趟，针对第 R[1] 至 R[2] 个元素进行。

##### 每一趟进行的过程

从第一个元素开始，比较两个相邻的元素。若相邻的元素的相对位置不正确，则进行交换；否则继续比较下面两个相邻的元素。

##### 结束条件

在任何一趟进行过程中，未出现交换。

```java
	for(int i = 0;i < arr.length -1;i++){

		for(int j = 0;j < arr.length - 1 - i;j++){

			if(arr[j] > arr[j + 1]){

				int temp = arr[j];
				arr[j] = arr[j + 1];
				arr[j + 1] = temp;

			}
		}
	}
```


### **快速排序**

快速排序通常明显比同为 $O_{nlogn}$ 的其他算法更快，因此常被采用，而且快排采用了分治法的思想，
所以在很多笔试面试中能经常看到快排的影子。

#### 排序思想：

1. 从数列中挑出一个元素，称为"基准"（pivot）
2. 重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面
   （相同的数可以到任一边）。在这个分区结束之后，该基准就处于数列的中间位置。这个称为分区（partition）操作。
3. 递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序。
4. 递归的最底部情形，是数列的大小是零或一，也就是永远都已经被排序好了。
   虽然一直递归下去，但是这个算法总会结束，因为在每次的迭代（iteration）中，它至少会把一个元素摆到它最后的位置去。

### 各种内部排序方法性能比较

![image.png](https://cdn.gxmnzl.xyz/img/SE0305.png)

1. *从平均时间而言* ：  
	快速排序最佳。但在最坏情况下时间性能不如堆排序和归并排序。
2. *从算法简单性看* ：  
	由于直接选择排序、直接插入排序和冒泡排序的算法比较简单，将其认为是简单算法。对于 Shell 排序、堆排序、快速排序和归并排序算法，其算法比较复杂，认为是复杂排序。
3. *从稳定性看* ：  
	直接插入排序、冒泡排序和归并排序时稳定的；而直接选择排序、快速排序、 Shell排序和堆排序是不稳定排序
4. *从待排序的记录数n的大小看* ：  
	n 较小时，宜采用简单排序；而n较大时宜采用改进排序

